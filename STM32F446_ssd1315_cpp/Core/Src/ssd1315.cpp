/*
 * ssd1315.cpp
 *
 *  Created on: Jan 20, 2024
 *      Author: jesse
 */

#include "ssd1315.hpp"
#include <math.h>

// The initialization sequence for the SSD1315
static uint8_t ssd1315_init_sequence[] = {
	0x00,			// Send commands
	0xAE,			// Set Display ON/OFF - AE=OFF, AF=ON
	0xD5, 0xf0,		// Set display clock divide ratio/oscillator frequency, set divide ratio
	0xA8, 0x3F,		// Set multiplex ratio (1 to 64) ... (height - 1)
	0xD3, 0x00,		// Set display offset. 00 = no offset
	0x40 | 0x00,	// Set start line address, at 0.
	0x8D, 0x14,		// Charge Pump Setting, 14h = Enable Charge Pump
	0x20, 0x00,		// Set Memory Addressing Mode - 00=Horizontal, 01=Vertical, 10=Page, 11=Invalid
	0xA0 | 0x00,	// Set Segment Re-map
	0xC0 | 0x00,	// Set COM Output Scan Direction
	0xDA, 0x12,		// Set COM Pins Hardware Configuration - 128x32:0x02, 128x64:0x12
	0x81, 0x80,		// Set contrast control register
	0xD9, 0x22,		// Set pre-charge period (0x22 or 0xF1)
	0xDB, 0x20,		// Set Vcomh Deselect Level - 0x00: 0.65 x VCC, 0x20: 0.77 x VCC (RESET), 0x30: 0.83 x VCC
	0xA4,			// Entire Display ON (resume) - output RAM to display
	0xA6,			// Set Normal/Inverse Display mode. A6=Normal; A7=Inverse
	0x2E,	  			// Deactivate Scroll command
	0x21, 0x00, 0x7f,	// Set column range
	0x22, 0x00, 0x07,	// Set page range
	0xAF,				// Set Display ON/OFF - AE=OFF, AF=ON
};

// The standard font for the OLED display
// 0-31 do not represent characters
// Extended with {, |, } and ~, char 0x7f is full block
static const uint8_t ssd1315_font6x8 [] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // sp
	0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, // !
	0x00, 0x00, 0x07, 0x00, 0x07, 0x00, // "
	0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14, // #
	0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12, // $
	0x00, 0x62, 0x64, 0x08, 0x13, 0x23, // %
	0x00, 0x36, 0x49, 0x55, 0x22, 0x50, // &
	0x00, 0x00, 0x05, 0x03, 0x00, 0x00, // '
	0x00, 0x00, 0x1c, 0x22, 0x41, 0x00, // (
	0x00, 0x00, 0x41, 0x22, 0x1c, 0x00, // )
	0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, // *
	0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, // +
	0x00, 0x00, 0x00, 0xA0, 0x60, 0x00, // ,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, // -
	0x00, 0x00, 0x60, 0x60, 0x00, 0x00, // .
	0x00, 0x20, 0x10, 0x08, 0x04, 0x02, // /
	0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
	0x00, 0x00, 0x42, 0x7F, 0x40, 0x00, // 1
	0x00, 0x42, 0x61, 0x51, 0x49, 0x46, // 2
	0x00, 0x21, 0x41, 0x45, 0x4B, 0x31, // 3
	0x00, 0x18, 0x14, 0x12, 0x7F, 0x10, // 4
	0x00, 0x27, 0x45, 0x45, 0x45, 0x39, // 5
	0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30, // 6
	0x00, 0x01, 0x71, 0x09, 0x05, 0x03, // 7
	0x00, 0x36, 0x49, 0x49, 0x49, 0x36, // 8
	0x00, 0x06, 0x49, 0x49, 0x29, 0x1E, // 9
	0x00, 0x00, 0x36, 0x36, 0x00, 0x00, // :
	0x00, 0x00, 0x56, 0x36, 0x00, 0x00, // ;
	0x00, 0x08, 0x14, 0x22, 0x41, 0x00, // <
	0x00, 0x14, 0x14, 0x14, 0x14, 0x14, // =
	0x00, 0x00, 0x41, 0x22, 0x14, 0x08, // >
	0x00, 0x02, 0x01, 0x51, 0x09, 0x06, // ?
	0x00, 0x32, 0x49, 0x59, 0x51, 0x3E, // @
	0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C, // A
	0x00, 0x7F, 0x49, 0x49, 0x49, 0x36, // B
	0x00, 0x3E, 0x41, 0x41, 0x41, 0x22, // C
	0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C, // D
	0x00, 0x7F, 0x49, 0x49, 0x49, 0x41, // E
	0x00, 0x7F, 0x09, 0x09, 0x09, 0x01, // F
	0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A, // G
	0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F, // H
	0x00, 0x00, 0x41, 0x7F, 0x41, 0x00, // I
	0x00, 0x20, 0x40, 0x41, 0x3F, 0x01, // J
	0x00, 0x7F, 0x08, 0x14, 0x22, 0x41, // K
	0x00, 0x7F, 0x40, 0x40, 0x40, 0x40, // L
	0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
	0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F, // N
	0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E, // O
	0x00, 0x7F, 0x09, 0x09, 0x09, 0x06, // P
	0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E, // Q
	0x00, 0x7F, 0x09, 0x19, 0x29, 0x46, // R
	0x00, 0x46, 0x49, 0x49, 0x49, 0x31, // S
	0x00, 0x01, 0x01, 0x7F, 0x01, 0x01, // T
	0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F, // U
	0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F, // V
	0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F, // W
	0x00, 0x63, 0x14, 0x08, 0x14, 0x63, // X
	0x00, 0x07, 0x08, 0x70, 0x08, 0x07, // Y
	0x00, 0x61, 0x51, 0x49, 0x45, 0x43, // Z
	0x00, 0x00, 0x7F, 0x41, 0x41, 0x00, // [
	0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55, // backslash
	0x00, 0x00, 0x41, 0x41, 0x7F, 0x00, // ]
	0x00, 0x04, 0x02, 0x01, 0x02, 0x04, // ^
	0x00, 0x40, 0x40, 0x40, 0x40, 0x40, // _
	0x00, 0x00, 0x01, 0x02, 0x04, 0x00, // '
	0x00, 0x20, 0x54, 0x54, 0x54, 0x78, // a
	0x00, 0x7F, 0x48, 0x44, 0x44, 0x38, // b
	0x00, 0x38, 0x44, 0x44, 0x44, 0x20, // c
	0x00, 0x38, 0x44, 0x44, 0x48, 0x7F, // d
	0x00, 0x38, 0x54, 0x54, 0x54, 0x18, // e
	0x00, 0x08, 0x7E, 0x09, 0x01, 0x02, // f
	0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C, // g
	0x00, 0x7F, 0x08, 0x04, 0x04, 0x78, // h
	0x00, 0x00, 0x44, 0x7D, 0x40, 0x00, // i
	0x00, 0x40, 0x80, 0x84, 0x7D, 0x00, // j
	0x00, 0x7F, 0x10, 0x28, 0x44, 0x00, // k
	0x00, 0x00, 0x41, 0x7F, 0x40, 0x00, // l
	0x00, 0x7C, 0x04, 0x18, 0x04, 0x78, // m
	0x00, 0x7C, 0x08, 0x04, 0x04, 0x78, // n
	0x00, 0x38, 0x44, 0x44, 0x44, 0x38, // o
	0x00, 0xFC, 0x24, 0x24, 0x24, 0x18, // p
	0x00, 0x18, 0x24, 0x24, 0x18, 0xFC, // q
	0x00, 0x7C, 0x08, 0x04, 0x04, 0x08, // r
	0x00, 0x48, 0x54, 0x54, 0x54, 0x20, // s
	0x00, 0x04, 0x3F, 0x44, 0x40, 0x20, // t
	0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C, // u
	0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C, // v
	0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C, // w
	0x00, 0x44, 0x28, 0x10, 0x28, 0x44, // x
	0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C, // y
	0x00, 0x44, 0x64, 0x54, 0x4C, 0x44, // z
	0x00, 0x00, 0x08, 0x36, 0x41, 0x00, // {, extended from this point
	0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, // |
	0x00, 0x41, 0x36, 0x08, 0x00, 0x00, // }
	0x00, 0x10, 0x08, 0x10, 0x20, 0x10, // ~
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // DEL = block
};

ssd1315_status_t ssd1315::init(void) {
	// Return status from I2C transmit
	HAL_StatusTypeDef ret;

	// Copy parameters to static globals for later use
	ret = HAL_I2C_Master_Transmit(phi2c, addr, ssd1315_init_sequence,
			                      sizeof ssd1315_init_sequence,
								  HAL_MAX_DELAY);
	// Return result
	return (ret == HAL_OK) ? SSD1315_OK : SSD1315_ERR;
}

// Plot a pixel in the buffer
ssd1315_status_t ssd1315::plotpixel(uint8_t x, uint8_t y, uint8_t color) {

	uint8_t bit = (63-y) & 0x7;
	uint8_t page = (63-y) >> 3;
	uint32_t address = (page << 7) + x + 1;

	if (x > 127 || y > 63) {
		return SSD1315_ERR;
	}

	if (color) {
		buffer[address] |= (1 << bit);
	} else {
		buffer[address] &= ~(1 << bit);
	}

	return SSD1315_OK;
}

// Write the buffer to the screen
ssd1315_status_t ssd1315::updatescreen(void) {

	// Write G-RAM buffer
	return (HAL_I2C_Master_Transmit(phi2c, addr, buffer, sizeof buffer,
			HAL_MAX_DELAY) == HAL_OK) ? SSD1315_OK : SSD1315_ERR;

}

// Put a character on the display
ssd1315_status_t ssd1315::putchar(char ch) {
	uint8_t i;
	uint8_t c;

	// Check range
	if (ch<32 || ch>127) {
		// Not in range
		c = 0x7f-32;
	} else {
		// Scale to correct character
		c = ch-32;
	}
	for (i= 0; i < 6; i++)
	{
		buffer[write_pointer+1] = ssd1315_font6x8[c*6+i];
		write_pointer++;
		if (write_pointer > 1023) {
			write_pointer = 0;
		}
	}
	return SSD1315_OK;
}

// Put a string on the display
ssd1315_status_t ssd1315::puts(char *s) {

	while (s != NULL && *s) {
		putchar(*s++);
	}

	return SSD1315_OK;
}

// Set the "cursor" to x,y where y is the PAGE NUMBER
ssd1315_status_t ssd1315::setpos(uint8_t x, uint8_t y) {
	write_pointer = ((y & 0x07) << 7) + (x & 0x7f);

	return SSD1315_OK;
}

// Fill the screen
void ssd1315::fillscreen(uint8_t val) {

	for (int i = 1; i < 1025; i++) {
		buffer[i] = val;
	}
}

/* Adapted from the AdaFruit library */
/* Using Bresenham's function */
/* Function ssd1315_plotline
 * Plots a line on the GLCD
 * @public
 * @in: x0  -- the start x coordinate
 * @in: y0  -- the start y coordinate
 * @in: x1  -- the stop x coordinate
 * @in: y1  -- the stop y coordinate
 * @in: color -- the RGB color specification
 * @out: void
 */
void ssd1315::plotline(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint8_t color) {
	register int16_t steep = abs(y1 - y0) > abs(x1 - x0);
	register int16_t dx, dy;
	register int16_t ystep;
	register int16_t err;

	if (steep) {
		ssd1315_swap_uint8_t(x0, y0);
		ssd1315_swap_uint8_t(x1, y1);
	}

	if (x0 > x1) {
		ssd1315_swap_uint8_t(x0, x1);
		ssd1315_swap_uint8_t(y0, y1);
	}

	dx = x1 - x0;
	dy = abs(y1 - y0);

	err = dx / 2;

	if (y0 < y1) {
		ystep = 1;
	} else {
		ystep = -1;
	}

	for (; x0 <= x1; x0++) {
		if (steep) {
			plotpixel(y0, x0, color);
		} else {
			plotpixel(x0, y0, color);
		}
		err -= dy;
		if (err < 0) {
			y0 += ystep;
			err += dx;
		}
	}
}

/* Adapted from the AdaFruit library */
/* Using Bresenham's function */
/* Function ssd1315_plotcircle
 * Plots a circle on the GLCD, with checks
 * @public
 * @in: x  -- the x coordinate
 * @in: y  -- the y coordinate
 * @in: r  -- the radius
 * @in: color -- the RGB color specification
 * @out: void
 */
void ssd1315::plotcircle(int16_t x0, int16_t y0, int16_t r, uint8_t color) {

    if (r<0) {
    	r = 0;
    }

    register int16_t f = 1 - r;
	register int16_t ddF_x = 1;
	register int16_t ddF_y = -2 * r;
	register int16_t x = 0;
	register int16_t y = r;

	plotpixel(x0, y0 + r, color);
	plotpixel(x0, y0 - r, color);
	plotpixel(x0 + r, y0, color);
	plotpixel(x0 - r, y0, color);

	while (x < y) {
		if (f >= 0) {
		  y--;
		  ddF_y += 2;
		  f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		plotpixel(x0 + x, y0 + y, color);
		plotpixel(x0 - x, y0 + y, color);
		plotpixel(x0 + x, y0 - y, color);
		plotpixel(x0 - x, y0 - y, color);
		plotpixel(x0 + y, y0 + x, color);
		plotpixel(x0 - y, y0 + x, color);
		plotpixel(x0 + y, y0 - x, color);
		plotpixel(x0 - y, y0 - x, color);
	}
}

// Plot a rectangle
void ssd1315::plotrect(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint8_t color)
{
	plotline(x0, y0, x0, y1, color);
	plotline(x0, y0, x1, y0, color);
	plotline(x0, y1, x1, y1, color);
	plotline(x1, y0, x1, y1, color);
}

// Set the contrast (0x00 - 0xFF)
ssd1315_status_t ssd1315::setcontrast(uint8_t contrast) {

	uint8_t buf[] = {0x00, 0x81, contrast};

	return (HAL_I2C_Master_Transmit(phi2c, addr, buf, sizeof buf,
			HAL_MAX_DELAY) == HAL_OK) ? SSD1315_OK : SSD1315_ERR;
}
